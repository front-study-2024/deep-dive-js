# 제너레이터와 async / await

## 제너레이터
코드 블록의 실행을 일시 중지 했다가 필요한 시점에 재개할 수 있는 특수한 함수로, ES6에 도입되었다.
1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.
	일반 함수 호출시, 제어권이 함수에게 넘어가고 함수 코드를 일괄 실행한다. 즉, 함수 호출자는 함수를 호출한 이후 함수 실행을 제어할 수 없다. 제너레이터 함수는 함수 실행을 함수 호출자가 제어할 수 있다. 즉, **함수 호출자가 함수 실행을 일시 중지시키거나 재개할 수 있다.** 함수 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 양도할 수 있다는 것을 의미한다.
2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다. 
	제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고, 함수 호출자로부터 상태를 전달받을 수도 있다. 즉, **호출자와 양방향으로 함수의 상태를 주고 받을 수 있다.** 
3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다. 
	일반 함수를 호출하면 함수 코드를 일괄 실행 후 값을 반환하지만, **제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.**

## 제너레이터 함수의 정의
`function*` 키워드로 제너레이터 함수를 선언할 수 있으며, 하나 이상의 `yield` 표현식을 포함한다. 애스터리스크(`*`)의 위치는 `function` 키워드와 함수 이름 사이라면 상관없지만, 일관성 유지를 위해 `function` 키워드 바로 뒤에 붙이는 것을 권장한다. 또한, 제너레이터 함수는 화살표 함수로 정의할 수 없다. 

```javascript
function* gen() {
  yield 1;
}

const gen = function* () {
  yield 1;
};

const obj = {
  * gen() {
    yield 1;
  }
};

class MyClass {
  * gen() {
    yield 1;
  }
}
```

## 제너레이터 객체
제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다. 제너레이터 함수가 반환한 제너레이터 객체는 이터러블이면서 동시에 이터레이터다.

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = gen();

// 이터러블은 Symbol.iterator 메서드를 직접 구현하거나 상속받은 객체이다.
console.log(Symbol.iterator in generator); // true
// 이터레이터는 next 메서드를 가진다. 
console.log('next' in generator); // true
```

제너레이터 객체는 `next` 메서드를 갖지만, 이터레이터에 없는 `return`, `throw` 메서드를 가진다.

- `next`: 제너레이터 함수의 `yield` 표현식까지 코드 블록을 실행하고 `yield`된 값을 `value` 프로퍼티 값으로, false를 `done` 프로퍼티 값으로 갖는 이터레이터 result 객체를 반환.
- `return`: 인수로 전달받은 값을 `value` 프로퍼티 값으로, `true`를 `done` 프로퍼티 값으로 갖는 이터레이터 result 객체 반환.
- `throw`: 인수로 전달받은 에러를 발생시키고 `value` 프로퍼티 값으로, `true`를 `done` 프로퍼티 값으로 이터레이터 result 객체를 반환한다.

```javascript
console.log(generator.next());
console.log(generator.return('End!'));
console.log(generator.throw('Error!'));
```

## 제너레이터의 일시 중지와 재개
제너레이터는 `yield` 키워드와 `next` 메서드를 통해 실행을 일시 중지 했다가 필요한 시점에 다시 재개할 수 있다. 제너레이터 객체의 `next` 메서드를 호출하면 `yield`표현식까지 실행되고 일시 중지 된다. 이 때, 함수의 제어권이 호출자로 양도된다. 또다시 `next` 메서드를 호출하면 일시 중지된 코드부터 실행을 재개하여 다음 `yield`표현식까지 실행되고 일시 중지 된다. 

이 때 제너레이터 객체의 `next` 메서드는 `value`와 `done` 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. `next` 메서드가 반환한 이터레이터 리절트 객체의 `value` 프로퍼티에는 yield 표현식에서 yield된 값이 할당되고 `done` 프로퍼티에는 제너레이터 함수가 끝까지 실행되었는지를 나타내는 불리언 값이 할당된다. 제너레이터 함수를 끝까지 실행하면 함수의 반환값이 `value`에 할당되고, `done` 프로퍼티에 `true`가 할당된다.

제너레이터의 `next` 메서드에는 인수를 전달할 수 있고, 이 인수는 제너레이터 함수의 `yield` 표현식을 할당받는 변수에 할당한다. yield 표현식의 평가 결과가 할당되지 않는 것에 주의해야 한다.

함수 호출자는 `next` 메서드를 통해 `yield` 표현식까지 함수를 실행시켜 제너레이터 객체가 관리하는 상태(yield된 값)를 꺼내올 수 있고, 인수 전달을 통해 제너레이터 객체에 상태를 밀어넣을 수 있다. 

## 제너레이터의 활용

### 이터러블의 구현
제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 것보다 간닪히 이터러블을 구현할 수 있다. 

```javascript
const fibonacci = (function* () {
  let [pre, cur] = [0, 1];
  while (true) {
     [pre, cur] = [cur, pre + cur];
     yield cur;
  }
}());
```

### 비동기 처리
제너레이터 함수는 `next` 메서드와 `yield` 표현식을 통해 함수 호출자와 함수의 상태를 주고받을 수 있고, 이르 ㄹ활용하여 프로미스를 사용한 비동기 처리를 동기 처리처럼 구현할 수 있다. 

## async / await
제너레이터를 사용해서 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있지만, 코드가 매우 복잡해지고 가독성도 나빠진다. ES8에서 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 구현할 수 있는 `async`/`await`가 도입되었다.

### `async`
`await` 키워드는 반드시 `async` 함수 내부에서 사용해야 한다. `async` 함수는 `async` 키워르를 사용해 정의하며 언제나 프로미스를 반환한다. `async` 함수가 명시적으로 프로미스를 반환하지 않더라도 `async` 함수는 암묵적으로 반환값을 resolve하는 프로미스를 반환한다. 

```javascript
async function f(n) { return n };
const f = async function (n) { return n };
const f = async n => n;
const obj = {
  async f(n) { return n; }
};
class C {
  async f(n) { return n; }
}
```

클래스의 `constructor` 메서드는 `async` 메서드가 될 수 없다. 클래스의 `constructor` 메서드는 인스턴스를 반환해야하지만 `async` 함수는 언제나 프로미스를 반환해야 한다.

### `await`
`await` 키워드는 프로미스가 `settled` 상태(비동기 처리가 수행된 상태)가 될 때까지 대기하다가 `setteld` 상태가 되면 프로미스가 `resolve`한 처리 결과를 반환한다. `await` 키워드는 반드시 프로미스 앞에 사용해야 한다. 하지만 모든 프로미스에 `await`를 사용하기보다 비동기 처리 사이에 인과관계가 없다면 `Promise.all` 등을 사용해 처리할 수 있다.

### 에러 처리
비동기 처리를 위한 콜백 패턴의 가장 큰 단점은 에러 처리가 어렵다는 문제가 있으며, 비동기 함수의 콜백 함수를 호출하는 것은 비동기 함수가 아니기 때문에 `try ... catch`문을 사용해 에러를 캐치할 수 없다. 하지만 `async`/`await`에서 에러 처리는 `try .. catch`문을 사용할 수 있다. 